<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="./css/wiki.css"/>
    <script src="https://code.jquery.com/jquery-3.1.1.slim.min.js" integrity="sha384-A7FZj7v+d/sdmMqp/nOQwliLvUsJfDHW+k9Omg/a/EheAdgtzNs3hpfag6Ed950n" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tether/1.4.0/js/tether.min.js" integrity="sha384-DztdAPBWPRXSA/3eYEEUWrWCy7G5KFbe8fFjk5JAIxUYHKkDx6Qin1DkWx51bBrb" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" integrity="sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/js/bootstrap.min.js" integrity="sha384-h0AbiXch4ZDo7tp9hKZ4TsHbi047NrKGLO3SEJAg45jXxnGIfYzk4Si90RDIqNm1" crossorigin="anonymous"></script>
</head>
<body>

    <nav class="navbar navbar-expand-sm bg-dark navbar-dark fixed-top">
       
        <ul class="navbar-nav">
            <li class="nav-item">
            <a class="nav-link" href="./index.html">Back</a>
            </li>
        </ul>
    </nav>
    <br><br><br>

<div class="flex-container">
<header>
  <h1>PAGE REPLACEMENT TECHNIQUES</h1>
</header>

<div class="container">
    <article class="article">      
        <div>
            <h2>Introduction</h2>   
            <hr/>
            <p>Paging is a type of contiguous memory allocation method. Comapared to segmentaiton paging is more advantageous as it avoids external fragmentation</p> 
            <p>The basic method for implementing paging involves breaking physical memory into fixed-sized blocks called frames and breaking logical memory into
                blocks of the same size called pages. When a process is to be executed, its
                pages are loaded into any available memory frames from their source (a file
                system or the backing store). The backing store is divided into fixed-sized
                blocks that are the same size as the memory frames or clusters of multiple
                frames. This rather simple idea has great functionality and wide ramifications.
                For example, the logical address space is now totally separate from the physical
                address space.</p>
            <p>The hardware support for paging is illustrated in Figure 1. Every address
                generated by the CPU is divided into two parts: a page number (p) and a page offset (d). The page number is used as an index into a page table. The page table
                contains the base address of each page in physical memory. This base address
                is combined with the page offset to define the physical memory address that
                is sent to the memory unit.</p>
            <img src="./Screenshot 2023-05-22 204504.png"/>
        </div>
        <br/><br/>
        <div>
            <h2>Page Replacement</h2>
            <hr/>
            <p>Page replacement is a technique used in operating systems to manage memory in a computer system with limited physical memory (RAM). In such systems, when all available memory is occupied by active processes and a new process requires memory space, the operating system needs to make room for it by evicting or replacing some existing pages from the main memory.</p>
            <p>The goal of page replacement is to maximize the efficient use of available memory and minimize the number of page faults. A page fault occurs when a process references a page that is not currently present in the main memory. When a page fault happens, the operating system needs to bring the required page from secondary storage (e.g., hard disk) into the main memory, which is a time-consuming operation.</p>
            <p>Page replacement algorithms determine which page(s) to evict when a page fault occurs. Some commonly used page replacement algorithms are:</p>
            <ol>  
                <li>FIFO (First-In-First-Out): This algorithm replaces the page that has been in the memory the longest. It uses a queue to keep track of the order in which pages were brought into memory.</li>
                <li>LRU (Least Recently Used): This algorithm replaces the page that has not been referenced for the longest time. It requires maintaining a record of the most recent usage of each page.</li>
                <li>Optimal: This algorithm selects the page that will not be used for the longest period of time in the future. It requires knowledge of future page references, which is not practical in real-world scenarios. However, it serves as an upper bound for evaluating other algorithms.</li>
            </ol>
        </div>
        <div>
            <p>The choice of a page replacement algorithm depends on various factors such as system workload, memory constraints, and the desired trade-off between page fault rate and computational overhead. Each algorithm has its advantages and disadvantages, and their performance can vary depending on the specific characteristics of the workload.</p>
        </div>
    </article>
</body>
</html>